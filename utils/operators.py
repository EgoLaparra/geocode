import geopandas as gpd
from shapely.geometry import Polygon, Point, MultiPoint, LineString, MultiLineString, mapping
from shapely import intersection, union, union_all, difference, get_parts
from shapely.ops import polygonize_full
from lxml import etree

from geometries import Geometries

# import for debug
from matplotlib import pyplot as plt
import numpy as np


# variables in case units and geocardinals generated by GPT-4 does not have quotes
N = "N"
S = "S"
E = "E"
W = "W"
NE = "NE"
NW = "NW"
SE = "SE"
SW = "SW"
C = "C"
KM = "KM"
MI = "MI"
NMI = "NMI"

# This function should be moved to another file later
def get_entity_geometries(geom, entity):
    entity_geometries = []
    entity_osms = entity.get("osm").split(" ")
    entity_types = entity.get("type").split(" ")
    entity_wikipedia = entity.get("wikipedia")
    for osm, otype in zip(entity_osms, entity_types):
        if otype != "node":
            osm_geometries = geom.get_geometries(osm, otype)
            for osm_geometry in osm_geometries:
                geometry = geom.process_geometry(osm_geometry)
                entity_geometries.append(geometry)
    return geom.unite_geometries(entity_geometries)

def get_entity_geojson(osm_str):
    osms = osm_str.split("_")
    shapes = []
    for osm in osms:
        shape = get_entity_geojson_osm(osm)
        shapes.append(shape)
    return polygon_to_geodf(union_all(shapes))


# Get entities from geojson for one single osm
def get_entity_geojson_osm(osm):
    gdf = gpd.read_file(f"../clean_data_database/{osm[:2]}/{osm}").set_geometry("geometry")
    if type(gdf.iloc[0]["geometry"]) == MultiLineString:
        shapes = get_parts(polygonize_full(gdf.iloc[0]["geometry"]))
        # if closed, return the union of all shapes
        if len(shapes) != 0:
            output_shape = union_all(shapes)
    else:
        output_shape = gdf.iloc[0]["geometry"]
    return output_shape
    # return gdf.rename_geometry("geom")


def polygon_to_geodf(polygon):
    df = gpd.GeoDataFrame([polygon], columns=['geom']).set_geometry('geom')
    df = df.set_crs(epsg=4326)

    return df

def get_distance_lat_long(lat1, lon1, lat2, lon2):
    # source code from https://www.geeksforgeeks.org/program-distance-two-points-earth/
    # The math module contains a function named
    # radians which converts from degrees to radians.
    # TODO: replace this method with one that can choose the best project to compute distance
    lon1 = np.radians(lon1)
    lon2 = np.radians(lon2)
    lat1 = np.radians(lat1)
    lat2 = np.radians(lat2)

    # Haversine formula
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = np.sin(dlat / 2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2)**2

    c = 2 * np.arcsin(np.sqrt(a))

    # Radius of earth in kilometers. Use 3956 for miles
    r = 6371

    # calculate the result in km
    return c * r

def create_arc(centerx, centery, radius, start_angle, end_angle, numsegments):
    """
    centerx: x coordinate of the arc center
    centery: y coordinate of the arc center
    radius: radius of the arc
    start_angle: start angle in degree, 0~360
    end_angle: end angle in degree, 0~360
    numsegments: number of points used to represent the arc
    """
    theta = np.radians(np.linspace(start_angle, end_angle, numsegments))
    x = centerx + radius * np.cos(theta)
    y = centery + radius * np.sin(theta)

    arc = LineString(np.column_stack([x, y]))
    return arc

class GeoCardinal:
    def __init__(self, *args):
        self.geocardinal = args[0]
        self.valid_GeoCardinals = ["N","S","E","W","NE","NW","SE","SW","C"]
        assert self.geocardinal.upper() in self.valid_GeoCardinals

    def opposite(self):
        if self.geocardinal == "N":
            return "S"
        elif self.geocardinal == "S":
            return "N"
        elif self.geocardinal == "E":
            return "W"
        elif self.geocardinal == "W":
            return "E"
        elif self.geocardinal == "NE":
            return "SW"
        elif self.geocardinal == "SW":
            return "NE"
        elif self.geocardinal == "NW":
            return "SE"
        elif self.geocardinal == "SE":
            return "NW"
        elif self.geocardinal == "C":
            return "C"



class GeoLocation:
    def __init__(self, location_id, *args, entity_id=None, data_source=None, geom=None):
        if entity_id == "GL091_496":
            a = 1
            pass
        if location_id is not None:
            osm = str(location_id)

            self.geoms = get_entity_geojson(osm)
            # location_id = str()
        else:
            self.geoms = geom

        assert type(self.geoms)==gpd.GeoDataFrame


def SubLocation(location, *args, fraction=1/3):
    assert type(location) == GeoLocation
    geom = Geometries()
    if len(args) > 0 and type(args[0])==GeoCardinal:
        geocardinal = args[0].geocardinal
        gdf = location.geoms
        xmin, ymin, xmax, ymax = gdf.iloc[0]['geom'].bounds
        x_diff = xmax - xmin
        y_diff = ymax - ymin
        if geocardinal == "N":
            mask_coord = [(xmin, ymax-y_diff*fraction), (xmin, ymax), (xmax, ymax), (xmax, ymax-y_diff*fraction)]
        elif geocardinal == "S":
            mask_coord = [(xmin, ymin), (xmin, ymin+y_diff*fraction), (xmax, ymin+y_diff*fraction), (xmax, ymin)]
        elif geocardinal == "W":
            mask_coord = [(xmin, ymin), (xmin, ymax), (xmin+x_diff*fraction, ymax), (xmin+x_diff*fraction, ymin)]
        elif geocardinal == "E":
            mask_coord = [(xmax-x_diff*fraction, ymin), (xmax-x_diff*fraction, ymax), (xmax, ymax), (xmax, ymin)]
        elif geocardinal == "NW":
            mask_coord = [(xmin, ymax-y_diff*fraction), (xmin, ymax), (xmin+x_diff*fraction, ymax), (xmin+x_diff*fraction, ymax-y_diff*fraction)]
        elif geocardinal == "NE":
            mask_coord = [(xmax-x_diff*fraction, ymax-y_diff*fraction), (xmax-x_diff*fraction, ymax), (xmax, ymax), (xmax, ymax-y_diff*fraction)]
        elif geocardinal == "SW":
            mask_coord = [(xmin, ymin), (xmin, ymin+y_diff*fraction), (xmin+x_diff*fraction, ymin+y_diff*fraction), (xmin+x_diff*fraction, ymin)]
        elif geocardinal == "SE":
            mask_coord = [(xmax-x_diff*fraction, ymin), (xmax-x_diff*fraction, ymin+y_diff*fraction), (xmax, ymin+y_diff*fraction), (xmax, ymin)]
        elif geocardinal == "C":
            mask_coord = [(xmin+x_diff*fraction, ymin+y_diff*fraction), (xmin+x_diff*fraction, ymax-y_diff*fraction), (xmax-x_diff*fraction, ymax*y_diff*fraction), (xmax-x_diff*fraction, ymin+y_diff*fraction)]
        else:
            assert False, "Unknown geocardinal"

        mask = Polygon(mask_coord)
        target_region = intersection(mask, gdf.iloc[0]['geom'])
        target_region_df = gpd.GeoDataFrame([target_region], columns=['geom']).set_geometry('geom')

        target_region_df = target_region_df.set_crs(epsg=4326)
        # Debug
        # _, ax = plt.subplots(figsize=(100., 100.))
        # target_region_df.plot(ax=ax, alpha=1., color="darkred", linewidth=2.)
        # plt.savefig(f"{geocardinal}.png")
        target_region_df = polygon_to_geodf(target_region)
        new_location = GeoLocation(None, geom=target_region_df)

        return new_location
    else:
        return location

def Adjacent(location, *args, buffer_rate=1, fraction=1/3):
    # adjacent with direction
    polygon = location.geoms.iloc[0]['geom']
    xmin, ymin, xmax, ymax = polygon.bounds # x: lat, y: long
    buffer_size = buffer_rate * np.sqrt((xmax-xmin)**2 + (ymax-ymin)**2)
    polygon_buffered = polygon.buffer(buffer_size, join_style="round")
    target_region = difference(polygon_buffered, polygon)
    target_region_df = polygon_to_geodf(target_region)

    # Debug
    # _, ax = plt.subplots(figsize=(100., 100.))
    # target_region_df.plot(ax=ax, alpha=1., color="darkred", linewidth=2.)
    # plt.savefig(f"adjacent.png")

    new_location = GeoLocation(None, geom=target_region_df)

    if len(args) > 0 and type(args[0])==GeoCardinal:
        return SubLocation(new_location, args[0], fraction=fraction)
    else:
        return new_location


def Distance(location, distance, unit, *args, buffer_rate = 0.5, fraction=1/3):
    polygon = location.geoms.iloc[0]['geom']
    unit = unit.lower()
    def normalize_unit(unit):
        if unit in ['kilometer', 'kilometers']:
            return "km"
        elif unit in ["mile", "miles"]:
            return "mi"
        elif unit in ["nautical mile", "nautical miles"]:
            return "nmi"
        else:
            return unit

    valid_units = ["km", "mi", "nmi"]
    unit = normalize_unit(unit)
    assert unit in valid_units
    unit_scale = 1
    if unit == "mi":
        unit_scale = 1.609
    elif unit_scale == "nmi":
        unit_scale = 1.852

    xmin, ymin, xmax, ymax = polygon.bounds # x: lat, y: long
    scale = (ymax - ymin) / get_distance_lat_long(xmin, ymin, xmin, ymax)
    distance_scaled = distance * scale * unit_scale

    polygon_buffered = polygon.buffer(distance_scaled, join_style="round")
    target_boundary = polygon_buffered.boundary

    buffer_size = buffer_rate * np.sqrt((xmax-xmin)**2 + (ymax-ymin)**2)
    target_region = target_boundary.buffer(buffer_size, join_style="round")
    target_region_df = polygon_to_geodf(target_region)
    new_location = GeoLocation(None, geom=target_region_df)

    # with geocardinal
    if len(args) > 0 and type(args[0])==GeoCardinal:
        return SubLocation(new_location, args[0], fraction=fraction)
    else:
        return new_location

def Between(location1, location2, *args):
    assert type(location1) == GeoLocation
    assert type(location2) == GeoLocation
    geom = Geometries()
    gdf1 = location1.geoms
    gdf2 = location2.geoms

    polygon1 = gdf1.iloc[0]['geom']
    polygon2 = gdf2.iloc[0]['geom']

    # get centroids
    centroid1 = polygon1.centroid
    centroid2 = polygon2.centroid
    slope_perpendicular = -(centroid1.coords[0][0]-centroid2.coords[0][0])/(centroid1.coords[0][1]-centroid2.coords[0][1])

    xmin1, ymin1, xmax1, ymax1 = polygon1.bounds
    xmin2, ymin2, xmax2, ymax2 = polygon1.bounds

    # set the two perpendicular lines to be slightly longer than the diagonal of the bounding rectangle
    line1_len = np.sqrt((xmax1-xmin1)**2+(ymax1-ymin1)**2)*1.1
    line2_len = np.sqrt((xmax2-xmin2)**2+(ymax2-ymin2)**2)*1.1

    dx1 = np.sqrt((line1_len/2)**2/(slope_perpendicular**2+1))
    dy1 = slope_perpendicular * dx1
    dx2 = np.sqrt((line2_len/2)**2/(slope_perpendicular**2+1))
    dy2 = slope_perpendicular * dx2

    line1 = LineString(((centroid1.coords[0][0]-dx1, centroid1.coords[0][1]-dy1), (centroid1.coords[0][0]+dx1, centroid1.coords[0][1]+dy1)))
    line2 = LineString(((centroid2.coords[0][0]-dx2, centroid2.coords[0][1]-dy2), (centroid2.coords[0][0]+dx2, centroid2.coords[0][1]+dy2)))

    line1_intersection = intersection(line1, polygon1)
    line2_intersection = intersection(line2, polygon2)
    mask = Polygon(((line1_intersection.bounds[0], line1_intersection.bounds[1]),\
                    (line1_intersection.bounds[2], line1_intersection.bounds[3]),\
                    (line2_intersection.bounds[2], line2_intersection.bounds[3]),\
                    (line2_intersection.bounds[0], line2_intersection.bounds[1])))
    target_region = difference(difference(mask, polygon1),polygon2)

    # # Debug
    # _, ax = plt.subplots(figsize=(100., 100.))
    # target_region_df.plot(ax=ax, alpha=1., color=["darkred","steelblue","steelblue","black","black"], linewidth=2.)
    # plt.savefig(f"between.png")
    target_region_df = polygon_to_geodf(target_region)
    new_location = GeoLocation(None, geom=target_region_df)

    # get centroid
    return new_location

def Union(location, *args):
    geom = Geometries()
    assert type(location) == GeoLocation
    if len(args) > 0:
        new_location = location
        for loc in args:
            assert type(loc) == GeoLocation
            target_region = union(new_location.geoms.iloc[0]["geom"], loc.geoms.iloc[0]["geom"])
            target_region_df = polygon_to_geodf(target_region)
            new_location.geoms = target_region_df
        return new_location
    else:
        return location


def Intersection(location, *args):
    geom = Geometries()
    assert type(location) == GeoLocation
    if len(args) > 0:
        new_location = location
        for loc in args:
            assert type(loc) == GeoLocation
            target_region = intersection(new_location.geoms.iloc[0]["geom"], loc.geoms.iloc[0]["geom"])
            target_region_df = polygon_to_geodf(target_region)
            new_location.geoms = target_region_df
            if target_region.is_empty:
                break
        return new_location
    else:
        return location

